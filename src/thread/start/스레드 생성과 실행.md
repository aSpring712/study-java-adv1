# 2. 스레드 생성과 실행
# 스레드 시작 1
스레드를 제대로 이해하려면 자바 메모리 구조를 확실히 이해하고 있어야 한다. <br/>
스레드를 시작하기 전에 잠깐 자바 메모리 구조를 복습하자.

## 자바 메모리 구조 복습
#### 자바 메모리 구조
- **메서드 영역(Method Area)**: 메서드 영역은 프로그램을 실행하는데 필요한 공통 데이터를 관리한다. 이 여역은 프로그램의 모든 영역에서 공유한다.
  - 클래스 정보: 클래스의 실행 코드(바이트 코드), 필드, 메서드와 생성자 코드 등 모든 실행 코드가 존재한다.
  - static 영역: `static` 변수들을 보관한다.
  - 런타임 상수 풀: 프로그램을 실행하는데 필요한 공통 리터럴 상수를 보관한다.
- **스택 영역(Stack Area)**: 자바 실행 시, 하나의 실행 스택이 생성된다. 각 스택 프레임은 지역 변수, 중간 연산 결과, 메서드호출 정보 등을
포함한다. 
  - 스택 프레임: 스택 영역에 쌓이는 네모 박스 하나가 스택 프레임이다. 메서드를 호출할 때 마다 하나의 스택 프레임이 쌓이고, 메서드가 종료되면
    해당 스택 프레임이 제거된다.
- **힙 영역(Heap Area)**: 객체(인스턴스)와 배열이 생성되는 영역이다. 가비지 컬렉션(GC)이 이루어지는 주요 영역이며, 더 이상 참조되지 않는 객체는
GC에 의해 제거된다.

> **참고**: 스택 영역은 더 정확히는 각 스레드별로 하나의 실행 스택이 생성된다. 따라서 스레드 수 만큼 스택이 생성된다. 지금은 스레드를 1개만
> 사용하므로 스택도 하나이다. 이후 스레드를 추가할 것인데, 그러면 스택도 스레드 수 만큼 증가한다.

## 스레드 생성
스레드를 직접 만들어보자. 그래서 해당 스레드에서 별도의 로직을 수행해보자. <br/>
스레드를 만들 때는 `Tread` 클래스를 상속 받는 방법과 `Runnable` 인터페이스를 구현하는 방법이 있다. <br/>
먼저 `Thread` 클래스를 상속 받아서 스레드를 생성해보자.

## 스레드 생성 - Thread 상속
자바는 많은 것을 객체로 다룬다. 자바가 예외를 객체로 다루듯이, 스레드도 객체로 다룬다. <br/>
스레드가 필요하면, 스레드 객체를 생성해서 사용하면 된다.

#### thread.start.HelloThread
- `Thread` 클래스를 상속하고, 스레드가 실행할 코드를 `run()` 메서드에 재정의한다.
- `Thread.currentThread()`를 호출하면 해당 코드를 실행하는 스레드 객체를 조회할 수 있다.
- `Thread.currentThread().getName()`: 실행 중인 스레드의 이름을 조회한다.

#### thread.start.HelloThreadMain
- 앞서 만든 `HelloThread` 스레드 객체를 생성하고 `start()` 메서드를 호출한다.
- `start()` 메서드는 스레드를 실행하는 아주 특별한 메서드이다.
- `start()`를 호출하면 `HelloThread` 스레드가 `run()` 메서드를 실행한다.

**주의!** `run` 메서드가 아니라 반드시 `start()` 메서드를 호출해야 한다. 그래야 별도의 스레드에서 `run()` 코드가
실행된다.

#### 스레드 생성 전
실행 결과를 보면 `main()` 메서드는 `main`이라는 이름의 스레드가 실행하는 것을 확인할 수 있다. 프로세스가 작동하려면
스레드가 최소한 하나는 있어야 한다. 그래야 코드를 실행할 수 있따. 자바는 실행 시점에 `main`이라는 이름의 스레드를
만들고 프로그램의 시작점인 `main()` 메서드를 실행한다.

#### 스레드 생성 후
- `HelloThread` 스레드 객체를 생성한 다음에 `start()` 메서드를 호출하면 자바는 스레드를 위한 별도의 스택 공간을
할당한다.
- 스레드 객체를 생성하고, 반드시 `start()`를 호출해야 스택 공간을 할당 받고 스레드가 작동한다.
- 스레드에 이름을 주지 않으면 자바는 스레드에 `Thread-0`, `Thread-1`과 같은 임의의 이름을 부여한다.
- 새로운 `Thread-0` 스레드가 사용할 전용 스택 공간이 마련되었다.
- `Thread-0` 스레드는 `run()` 메서드의 스택 프레임을 스택에 올리면서 `run()` 메서드를 시작한다.

#### 메서드를 실행하면 스택 위에 스택 프레임이 쌓인다
- `main` 스레드는 `main()` 메서드의 스택 프레임을 스택에 올리면서 시작한다.
- 직접 만드는 스레드는 `run()` 메서드의 스택 프레임을 스택에 올리면서 시작한다.

실행 결과를 보면 `Thread-0` 스레드가 `run()` 메서드를 실행한 것을 확인할 수 있다.

#### 시간의 흐름으로 분석
- `main` 스레드가 `HelloThread` 인스턴스를 생성한다. 이때 스레드에 이름을 부여하지 않으면 자바가 `Thread-0`
`Thread-1`과 같은 임의의 이름을 부여한다.
- `start()` 메서드를 호출하면, `Thread-0` 스레드가 시작되면서 `Thread-0` 스레드가 `run()` 메서드를 호출한다.
- 여기서 핵심은 `main` 스레드가 `run()` 메서드를 실행하는게 아니라 `Thread-0` 스레드가 `run()` 메서드를
실행한다는 점이다.
- `main` 스레드는 단지 `start()` 메서드를 통해 `Thread-0`스레드에게 실행을 지시할 뿐이다. 다시 강조하지만
`main` 스레드가 `run()`을 호출하는 것이 아니다! `main` 스레드는 다른 스레드에게 일을 시작하라고 지시만 하고,
바로 `start()` 메서드를 빠져나온다.
- 이제 `main` 스레드와 `Thread-0` 스레드는 동시에 실행된다.
- `main` 스레드 입장에서 보면 그림의 1, 2, 3번 코드를 멈추지 않고 계속 수행한다. 그리고 `run()` 메서드는
`main`이 아닌 별도의 스레드에서 실행된다.

#### 스레드 간 실행 순서는 보장하지 않는다.
스레드는 동시에 실행되기 때문에 스레드 간에 실행 순서는 얼마든지 달라질 수 있다. 따라서 다음과 같이 다양한 실행
결과가 나올 수 있다.

`main` 스레드가 빨리 실행된 경우
```java
main: main() start
main: start() 호출 전
main: start() 호출 후
main: main() end
Thread-0: run()
```
- `main` 스레드가 모든 로직을 다 수행한 다음에 `Thread-0`가 수행된다.

`Thread-0` 스레드가 빨리 실행된 경우
```java
main: main() start
main: start() 호출 전
Thread-0: run()
main: start() 호출 후
main: main() end
```
- `Thread-0` `start()` 이후 `Thread-0`이 먼저 수행되고, `main`이 수행된다.

`main` 스레드 중간에 `Thread-0` 스레드가 실행된 경우
```java
main: main() start
main: start() 호출 전
main: start() 호출 후
Thread-0: run()
main: main() end
```
- `main` 스레드가 "start() 호출 후"를 출력한 다음에 `Thread-0` 스레드 `run()`을 출력한다.

스레드 간의 실행 순서는 얼마든지 달라질 수 있다. <br/>
CPU 코어가 2개여서 물리적으로 정말 동시에 실행될 수도 있고, 하나의 CPU 코어에 시간을 나누어 실행될 수도 있다.
그리고 한 스레드가 얼마나 오랜기간 실행되는지도 보장하지 않는다. 한 스레드가 먼저 다 수행된 다음에 다른 스레드가
수행될 수도 있고, 둘이 완전히 번갈아 가면서 수행되는 경우도 있다.

스레드는 순서와 실행 기간을 모두 보장하지 않는다. 이것이 바로 멀티스레드다!

---

# 스레드 시작 2
## start() vs run()
스레드의 `start()` 대신에 재정의한 `run()` 메서드를 직접 호출하면 어떻게 될까?

#### thread.start.BadThreadMain
- `helloThread.run()`: `start()`를 호출해야 하지만 여기서는 문제를 확인하기 위해 `run()`을 직접 호출한다.

#### run() 직접 호출
- 실행 결과를 잘 보면 별도의 스레드가 `run()`을 실행하는 것이 아니라, `main` 스레드가 `run()` 메셔드를 호출할
것을 확인할 수 있다.
- 자바를 처음 실행하면 `main` 스레드가 `main()` 메서드를 호출하면서 시작한다.
- `main` 스레드는 `HelloThread` 인스턴스에 있는 `run()` 이라는 메서드를 호출한다.
- `main` 스레드가 `run()` 메서드를 실행했기 때문에 `main` 스레드가 사용하는 스택 위에 `run()` 스택 프레임이
올라간다.

결과적으로 `main` 스레드에서 모든 것을 처리한 것이 된다.

스레드의 `start()` 메서드는 스레드에 스택 공간을 할당하면서 스레드를 시작하는 아주 특별한 메서드이다. 그리고 해당
스레드에서 `run()` 메서드를 실행한다. 따라서 `main` 스레드가 아닌 별도의 스레드에서 재정의한 `run()` 메서드를
실행하려면, 반드시 `start()` 메서드를 호출해야 한다.

> **참고**: 스레드와 메모리 구조에 대한 부분은 강의를 진행하면서 점점 더 자세히 설명한다.

---

# 데몬 스레드
## 데몬 스레드
스레드는 사용자(user) 스레드와 데몬(daemon) 스레드 2가지 종류로 구분할 수 있다.

#### 사용자 스레드(non-daemon 스레드)
- 프로그램의 주요 작업을 수행한다.
- 작업이 완료될 때까지 실행된다.
- 모든 user 스레드가 종료되면 JVM도 종료된다.

#### 데몬 스레드
- 백그라운드에서 보조적인 작업을 수행한다.
- 모든 user 스레드가 종료되면 데몬 스레드는 자동으로 종료된다.

JVM은 데몬 스레드의 실행 완료를 기다리지 않고 종료된다. 데몬 스레드가 아닌 모든 스레드가 종료되면, 자바 프로그램도
종료된다.

> **용어 - 데몬**: 그리스 신화에서 데몬은 신과 인간 사이의 중간적 존재로, 보이지 않게 활동하며 일상적인 일들을
> 도왔다. 이런 의미로 컴퓨터 과학에서는 사용자에게 직접적으로 보이지 않으면서 시스템의 백그라운드에서 작업을
> 수행하는 것을 데몬 스레드, 데몬 프로세스라 한다. 예를 들어서 사용하지 않는 파일이나 메모리를 정리하는 작업들이 있다.

#### thread.start.DaemonThreadMain
- `setDaemon(true)`: 데몬 스레드로 설정한다.
- 데몬 스레드 여부는 `start()` 실행 전에 결정해야 한다. 이후에는 변경되지 않는다.
- 기본 값은 `false`이다. (user 스레드가 기본)

> **참고**: `run()` 메서드 안에서 `Thread.sleep()`을 호출할 때 체크 예외인 `InterruptedException`을
> 밖으로 던질 수 없고 반드시 잡아야 한다. `run()` 메서드는 체크 예외를 밖으로 던질 수 없는데, 이 부분은 뒤에서
> 설명한다.

실행 결과 - setDaemon(true)
```java
main: main() start
main: main() end
Thread-0: run() start
```
- `setDaemon(true)`로 설정해보자.
- `Thread-0`는 데몬 스레드로 설정된다.
- 유일한 user 스레드인 `main` 스레드가 종료되면서 자바 프로그램도 종료된다.
- 따라서 `run() end`가 출력되기 전에 프로그램이 종료된다.

실행 결과 - setDaemon(false)
```java
main: main() start
main: main() end
Thread-0: run() start
Thread-0: run() end
```
- `setDaemon(false)`로 설정해보자.
- `Thread-0`는 user 스레드로 설정된다.
- `main` 스레드가 종료되어도, user 스레드인 `Thread-0`가 종료될 때 까지 자바 프로그램은 종료되지 않는다.
- 따라서 `Thread-0: run() end`가 출력된다.
- user 스레드인 `main` 스레드와 `Thread-0` 스레드가 모두 종료되면서 자바 프로그램도 종료된다.

---

# 스레드 생성 - Runnable
스레드를 만들 때는 `Thread` 클래스를 상속 받는 방법과 `Runnable` 인터페이스를 구현하는 방법이 있다. <br/>
앞서 `Thread` 클래스를 상속 받아서 스레드를 생성해보았다. <br/>
이번에는 `Runnable` 인터페이스를 구현하는 방식으로 스레드를 생성해보자.

#### Runnable 인터페이스
```java
package java.lang;

public interface Runnable {
	void run();
}
```
- 자바가 제공하는 스레드 실행용 인터페이스

#### thread.start.HelloRunnable, HelloRunnableMain
실행 결과는 기존과 같다. 차이가 있다면, 스레드와 해당 스레드가 실행할 작업이 서로 분리되어 있다는 점이다. <br/>
스레드 객체를 생성할 때, 실행할 작업을 생성자로 전달하면 된다.

## Thread 상속 vs Runnable 구현
#### 스레드 사용할 때는 `Thread`를 상속 받는 방법보다 `Runnable` 인터페이스를 구현하는 방식을 사용하자.
두 방식이 서로 장단점이 있지만, 스레드를 생성할 때는 `Thread` 클래스를 상속하는 방식보다 `Runnable` 인터페이스를
구현하는 방식이 더 나은 선택이다.

#### Thread 클래스 상속 방식
**장점**
- 간단한 구현: `Thread` 클래스를 상속받아 `run()` 메서드만 재정의하면 된다.
**단점**
- 상속의 제한: 자바는 단일 상속만을 허용하므로 이미 다른 클래스를 상속받고 있는 경우 `Thread` 클래스를 상속받을
수 없다.
- 유연성 부족: 인터페이스를 사용하는 방법에 비해 유연성이 떨어진다.

#### Runnable 인터페이스를 구현 방식
**장점**
- 상속의 자유로움: `Runnable` 인터페이스 방식은 다른 클래스를 상속받아도 문제없이 구현할 수 있다.
- 코드의 분리: 스레드와 실행할 작업을 분리하여 코드의 가독성을 높일 수 있다.
- 여러 스레드가 동일한 `Runnable` 객체를 공유할 수 있어 자원 관리를 효율적으로 할 수 있다.
**단점**
- 코드가 약간 복잡해질 수 있다. `Runnable` 객체를 생성하고 이를 `Thread`에 전달하는 과정이 추가된다.

정리하자면 `Runnable` 인터페이스를 구현하는 방식을 사용하자. 스레드와 실행할 작업을 명확히 분리하고, 인터페이스를
사용하므로 `Thread` 클래스를 직접 상속하는 방식보다 더 유연하고 유지보수 하기 쉬운 코드를 만들 수 있다.

---

# 로거 만들기
현재 어떤 스레드가 코드를 실행하는지 출력하기 위해 다음과 같이 긴 코드를 작성하는 것은 너무 번거롭다.
```java
System.out.println(Thread.currentThread().getName() = ": run()");
```

다음 예시와 같이 실행하면, 현재 시간, 스레드 이름, 출력 내용 등이 한번에 나오는 편리한 기능을 만들어보자.
```java
log("hello thread");
log(123);
```

**실행 결과**
```text
15:39:02.000 [ main] hello thread
15:39:02.002 [ main] 123
```

#### util.MyLogger
- `util`이라는 패키지를 사용했다. 프로젝트 전반에 사용되는 유틸리티라는 뜻이다.
- 현재 시간을 원하는 포멧으로 출력하기 위해 `DateTimeFormatter`를 사용한다.
- `printf`에서 `%s`는 문자열을 뜻한다. 인자를 순서대로 사용한다. 여기서는 현재 시간, 스레드 이름, 출력할 객체
순서이다.
  - 참고로 마지막의 출력할 객체는 문자열이 아니라 `Object` 타입인데, `%s`를 사용하면 `toString()`을 사용해서
  문자열로 변환 후 출력한다. 이렇게 `Object` 타입을 사용하면 문자열 뿐만 아니라 객체도 출력할 수 있다.
- `%9s`는 다음과 같이 문자를 출력할 때 9칸을 확보한다는 뜻이다. 9칸이 차지 않으면 왼쪽에 그 만큼 비워둔다.
이 기능은 단순히 출력시 정렬을 깔끔하게 하려고 사용한다.
  - 예)
    - `[     main]`: 앞에 5칸 공백
    - `[ Thread-0]`: 앞에 1칸 공백

#### util.MyLoggerMain
- 사용할 때는 지금과 같이 `import static`을 사용하면 메서드 이름만으로 간단히 사용할 수 있다.

스레드를 학습할 때는 스레드 이름, 그리고 해당 스레드가 언제 실행되었는지 확인하는 것이 중요하다. <br/>
앞으로는 `System.out.println()` 대신에 스레드 이름과 실행 시간을 알려주는 `MyLogger`를 사용하겠다.

---

# 여러 스레드 만들기
이번에는 많은 스레드를 어떻게 한 번에 만드는지 알아보자.

단순히 스레드 3개를 생성하고 실행해보자.

#### thread.start.ManyThreadMainV1
- 실행 결과는 다를 수 있다. 스레드의 실행 순서는 보장되지 않는다.
- 스레드 3개를 생성할 때 모두 같은 `HelloRunnable` 인스턴스(`x001`)를 스레드의 실행 작업으로 전달했다.
- `Thread-0`, `Thread-1`, `Thread-2`는 모두 `HelloRunnable` 인스턴스에 있는 `run()` 메서드를
실행한다.

스레드 100개를 생성하고 실행해보자.
#### thread.start.ManyThreadMainV2
반복문을 사용하면 스레드의 숫자를 유동적으로 변경하면서 실행할 수 있다.
- 실행 결과는 다를 수 있다. 스레드의 실행 순서는 보장되지 않는다.

---

# Runnable을 만드는 다양한 방법
중첩 클래스를 사용하면 `Runnable`을 더 편리하게 만들 수 있다. (중첩 클래스는 자바 중급 1편 참고)

참고로 모두 결과는 같다.

## 정적 중첩 클래스 사용
#### thread.start.InnerRunnableMainV1
- 특정 클래스 안에서만 사용되는 경우 이렇게 중첩 클래스를 사용하면 된다.

## 익명 클래스 사용
#### thread.start.InnerRunnableMainV2
- 특정 메서드 안에서만 간단히 정의하고 사용하고 싶다면 익명 클래스를 사용하면 된다.

## 익명 클래스 변수 없이 직접 전달
#### thread.start.InnerRunnableMainV3
- 익명 클래스를 참조하는 변수를 만들지 않고 직접 전달할 수 있다.

## 람다
#### thread.start.InnerRunnableMainV4
- 람다를 사용하면 메서드(함수) 코드 조각을 전달할 수 있다.
- 우리는 아직 람다를 학습하지 않았기 때문에 정적 중첩 클래스나 익명 클래스를 주로 사용하겠다.
- 참고로 람다는 별도의 강의에서 다룰 예정이다.

---

# 문제와 풀이

---

# 정리